* Add Relation#extend
  * Adds a computed attribute based on the other values in the tuple
  * The object added responds to #call, and accepts the tuple as an
    argument. The return value is used as the value in the tuple.

* Add Relation#summarize
  * Adds a computed attribute that summarizes other values in the tuple
    and projects away attributes.
  * The values from each tuple that are being "folded" together are
    passed into the #call method, which can perform any operation
    on the values. The return value is used as the value in the tuple.

* Remove Order, Reverse, Limit and Offset from the Relation inheritance chain
  * Instead make it so they are proxy classes that wrap Relations, but
    proxy method calls to the Relation methods, and then wrap the return
    value (assuming it's a Relation) in a copy of itself.
  * Also this will allow knowledge of #directions to be removed from
    all the Relation classes. Only the Ranking classes will need to know
    about directions.
  * We can also do things like optimize away an Order that is not
    wrapped by a Limit/Offset if it is wrapped in Join or Set relation.
    We can do this because joining sorted relations results in
    an undefined sort order depending on the algorithm used to join
    the tuples. The correct approach to get unambiguous results is to
    wrap the Join in an Order.
  * The Reverse class will probably not be needed either. All we need is
    for the #reverse method to create a new Order with the directions
    reversed.
  * Remove the knowledge of directions from materialized relations
    and instead wrap materialized relations in the Order object
    if any.

* Add further optimizations:
  * Operation Order:
    * Projection should follow Rename
      * When a Projection contains a Restriction, wrap the Projection
        in the Restriction, projecting away any attributes not used in
        the restriction. If there are any remaining attributes, then
        wrap the operation in a Projection removing those attributes.
        * If all attributes are being used in the Restriction do nothing
      * When a Projection contains a Join, wrap the Join with a Projection
        of all the headers, minus those used in the Join. If there were
        any used, then wrap the whole operation in a Projection with
        the remaining attributes.
        * If all the attributes are used in the Join, do nothing
        * Try to use the same approach for Product
        * Test if it's possible to fully distribute projections over
          joins rather than splitting it up like this.
    * Restriction should follow Projection
      * Restriction optimizations:
        * "attr > ? OR attr > ?" -> "attr > ?", with the least restrictive value
          * Do the same for >=, <, <=
        * "attr > ? AND attr > ?" -> "attr > ?", with the most restrictive value
          * Do the same for >=, <, <=
        * "attr > 5 OR attr == 5" -> "attr >= 5"
        * "attr < 5 OR attr == 5" -> "attr <= 5"
        * "attr" = "string" AND "attr" =~ /string/ -> "attr" = "string"
          * If the regexp matches the constant, then it should be
            optimized down to a constant match. If it does not match
            then it should be optimized to False.
        * Constant folding, eg:
          "attr1 > attr2 AND attr1 = 5" -> "5 > attr2 AND attr1 = 5"
          * This will probably only work across Conjunctions.
        * "attr > 5 AND attr = 6" -> "attr = 6", because attr must be
          equal to 6. this will probably be related to constant folding;
          the first expression will become 6 > 5, which evaluates to
          True, then the expression is True AND attr = 6, which simplifies
          down to attr = 6.
        * "attr < 5 AND attr = 6" -> "False", because attr must be equal to
          6, and 6 < 5 evaluates to False.  False AND attr = 6 simplifies
          down to False.
      * Figure out how to reorganize the Restriction predicates so that all
        similar operations are closer together to allow more efficient
        optimizations. This would allow optimizations of stuff like this:

          "attr1 = ? OR attr2 = ? OR attr1 = ?"

        Into:

          "attr1 IN(..) OR attr2 = ?"
    * Rename should distribute over Join, Product and Set operations
      * The goal should be to push Rename as close to the base tables
        as possible so that the names of attribute will be consistent
        throughout the whole tree.
  * A Union of relations with the same base, header, and restrictions should
    try to combine into a single relation with the restrictions using OR.
  * An Intersection of relations with the same base, header, and restrictions
    should try to combine into a single relation with the restrictions using
    AND.
  * A Difference of relations with the same base and restrictions should
    try to combine into a single relation with the restrictions using NOT.
  * Join Optimizations
    * When a Join contains a Join, and the size of the base relations is
      known, join the smallest with the largest, and then join that result
      with the remaining relation.
    * Make sure the smallest relation (with a known size) is always the
      right-most operation.

* Allow Inclusion match to accept a Relation
  * Ensure that Inclusion can have the left/right be an Array of
    Attributes.
  * Consider transforming the value provided to an Inclusion into
    a Relation.

* Update Attributes so that constraints are modelled using predicates,
  so that when "join-ability" is tested, the predicates can just be
  compared for equality.
  * Create an object that can wrap a predicate, and if it fails it will
    set the object's error state, and then propagate the status to the
    caller. This will allow a "complex" predicate to set the errors
    on tuples, while still allowing all the same objects to be used.

* Add Relation#antijoin

* Add Relation#nest and Relation#unnest

* Add aliases for some common operations in Method classes, eg:
  * Predicates:
    * Alias #== to #eq (may break alot)
    * Alias #!= to #ne (in 1.9 only)
    * Alias #>= to #gte
    * Alias #> to #gt
    * Alias #<= to #lte
    * Alias #< to #lt
    * Alias #=~ to #match
  * Direction:
    * Alias #@+ to #asc
    * Alias #@- to #desc

* Update memoization to take into account the arguments passed into
  the method. It should memoize differently for different
  methods. Perhaps it could have a special case for methods
  with a 0-arity vs n-arity methods, but it needs to handle cases
  like with #hash that accept no args, and #optimize that accepts
  1 arg.
